# Generated from TommyWiC.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,38,164,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,37,8,1,1,2,5,2,40,8,2,10,2,12,
        2,43,9,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,51,8,3,1,4,1,4,3,4,55,8,4,1,
        5,1,5,1,5,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,5,7,70,8,7,10,
        7,12,7,73,9,7,1,7,1,7,3,7,77,8,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,9,
        1,9,1,9,1,9,1,9,1,9,3,9,92,8,9,1,10,1,10,1,10,1,10,1,10,1,11,1,11,
        1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,3,11,117,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,1,11,5,11,129,8,11,10,11,12,11,132,9,11,1,12,1,12,1,12,
        1,12,1,12,5,12,139,8,12,10,12,12,12,142,9,12,1,13,1,13,1,13,1,13,
        1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
        1,13,3,13,162,8,13,1,13,0,2,22,24,14,0,2,4,6,8,10,12,14,16,18,20,
        22,24,26,0,0,174,0,28,1,0,0,0,2,36,1,0,0,0,4,41,1,0,0,0,6,50,1,0,
        0,0,8,54,1,0,0,0,10,56,1,0,0,0,12,59,1,0,0,0,14,62,1,0,0,0,16,80,
        1,0,0,0,18,85,1,0,0,0,20,93,1,0,0,0,22,116,1,0,0,0,24,133,1,0,0,
        0,26,161,1,0,0,0,28,29,3,2,1,0,29,1,1,0,0,0,30,31,5,27,0,0,31,32,
        3,4,2,0,32,33,5,28,0,0,33,37,1,0,0,0,34,35,5,27,0,0,35,37,5,28,0,
        0,36,30,1,0,0,0,36,34,1,0,0,0,37,3,1,0,0,0,38,40,3,6,3,0,39,38,1,
        0,0,0,40,43,1,0,0,0,41,39,1,0,0,0,41,42,1,0,0,0,42,5,1,0,0,0,43,
        41,1,0,0,0,44,51,3,20,10,0,45,51,3,24,12,0,46,51,3,8,4,0,47,51,3,
        14,7,0,48,51,3,16,8,0,49,51,3,18,9,0,50,44,1,0,0,0,50,45,1,0,0,0,
        50,46,1,0,0,0,50,47,1,0,0,0,50,48,1,0,0,0,50,49,1,0,0,0,51,7,1,0,
        0,0,52,55,3,10,5,0,53,55,3,12,6,0,54,52,1,0,0,0,54,53,1,0,0,0,55,
        9,1,0,0,0,56,57,5,13,0,0,57,58,5,26,0,0,58,11,1,0,0,0,59,60,5,13,
        0,0,60,61,3,22,11,0,61,13,1,0,0,0,62,63,5,9,0,0,63,64,3,22,11,0,
        64,71,3,4,2,0,65,66,5,10,0,0,66,67,3,22,11,0,67,68,3,4,2,0,68,70,
        1,0,0,0,69,65,1,0,0,0,70,73,1,0,0,0,71,69,1,0,0,0,71,72,1,0,0,0,
        72,76,1,0,0,0,73,71,1,0,0,0,74,75,5,11,0,0,75,77,3,4,2,0,76,74,1,
        0,0,0,76,77,1,0,0,0,77,78,1,0,0,0,78,79,5,12,0,0,79,15,1,0,0,0,80,
        81,5,7,0,0,81,82,3,22,11,0,82,83,3,4,2,0,83,84,5,8,0,0,84,17,1,0,
        0,0,85,86,5,35,0,0,86,87,3,24,12,0,87,88,5,36,0,0,88,91,5,37,0,0,
        89,92,3,24,12,0,90,92,3,4,2,0,91,89,1,0,0,0,91,90,1,0,0,0,92,19,
        1,0,0,0,93,94,5,24,0,0,94,95,5,5,0,0,95,96,3,22,11,0,96,97,5,6,0,
        0,97,21,1,0,0,0,98,99,6,11,-1,0,99,117,5,24,0,0,100,117,5,25,0,0,
        101,117,5,1,0,0,102,117,5,2,0,0,103,104,5,14,0,0,104,105,3,22,11,
        0,105,106,5,15,0,0,106,107,3,22,11,0,107,108,5,16,0,0,108,117,1,
        0,0,0,109,110,5,17,0,0,110,111,3,22,11,0,111,112,5,18,0,0,112,113,
        3,22,11,3,113,117,1,0,0,0,114,115,5,19,0,0,115,117,3,22,11,2,116,
        98,1,0,0,0,116,100,1,0,0,0,116,101,1,0,0,0,116,102,1,0,0,0,116,103,
        1,0,0,0,116,109,1,0,0,0,116,114,1,0,0,0,117,130,1,0,0,0,118,119,
        10,5,0,0,119,120,5,20,0,0,120,121,3,22,11,0,121,122,5,21,0,0,122,
        129,1,0,0,0,123,124,10,1,0,0,124,125,5,3,0,0,125,126,3,22,11,0,126,
        127,5,4,0,0,127,129,1,0,0,0,128,118,1,0,0,0,128,123,1,0,0,0,129,
        132,1,0,0,0,130,128,1,0,0,0,130,131,1,0,0,0,131,23,1,0,0,0,132,130,
        1,0,0,0,133,134,6,12,-1,0,134,135,3,26,13,0,135,140,1,0,0,0,136,
        137,10,1,0,0,137,139,3,26,13,0,138,136,1,0,0,0,139,142,1,0,0,0,140,
        138,1,0,0,0,140,141,1,0,0,0,141,25,1,0,0,0,142,140,1,0,0,0,143,144,
        5,24,0,0,144,145,5,31,0,0,145,162,3,22,11,0,146,147,5,29,0,0,147,
        148,5,24,0,0,148,149,5,33,0,0,149,162,3,22,11,0,150,151,5,24,0,0,
        151,152,5,32,0,0,152,162,3,22,11,0,153,154,5,30,0,0,154,155,5,24,
        0,0,155,156,5,34,0,0,156,162,3,22,11,0,157,158,5,24,0,0,158,162,
        5,22,0,0,159,160,5,23,0,0,160,162,5,24,0,0,161,143,1,0,0,0,161,146,
        1,0,0,0,161,150,1,0,0,0,161,153,1,0,0,0,161,157,1,0,0,0,161,159,
        1,0,0,0,162,27,1,0,0,0,12,36,41,50,54,71,76,91,116,128,130,140,161
    ]

class TommyWiCParser ( Parser ):

    grammarFileName = "TommyWiC.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Anything for my princes'", "'I did not hit her. It's not true! It's bullshit, I DID NOT!'", 
                     "'is a quack,'", "'is a duck'", "'is just a'", "'CHEEP CHEEP CHEEP!'", 
                     "'This is a great party, you invited all my friends'", 
                     "'Everybody betray me. I'm fed up with this world!'", 
                     "'I have an announcement to make. We are expecting'", 
                     "'Alright, let's toss the ball around'", "'Anyway, how is your sex life?'", 
                     "'I'm tired. I'm wasted. I love you, darling'", "'Yeah, you can say that again'", 
                     "'I'm so happy I have'", "'as my best friend, and I love'", 
                     "'so much'", "'Look, this is not right. You are living with a'", 
                     "'and doing sex with a'", "'It's bullshit!'", "'is great but'", 
                     "'is a crowd'", "'is as good in bed as he is at getting promotions... Awful!'", 
                     "'You're acting like a kid. Just grow up,'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'Oh hi Mark'", "'What a story, Mark'", 
                     "'Get out! Get out! Get out of'", "'You are taking'", 
                     "'and your stupid mother'", "'let's go inside and eat some'", 
                     "'life,'", "'apart,'", "'Just what sort of perverted filth are you planning to use'", 
                     "'for!?'", "'Come on, stop. It was a mistake'" ]

    symbolicNames = [ "<INVALID>", "TRUE", "FALSE", "NOTEQ1", "NOTEQ2", 
                      "ASSIGN1", "ASSIGN2", "WHILE", "END", "IF", "ELIF", 
                      "ELSE", "ENDIF", "PRINT", "AND1", "AND2", "AND3", 
                      "OR1", "OR2", "NOT", "LESS1", "LESS2", "DECREMENT", 
                      "INCREMENT", "ID", "INT", "STRING", "BEGINMAIN", "ENDMAIN", 
                      "SUBOP1", "DIVOP1", "ADDOP", "MULOP", "SUBOP2", "DIVOP2", 
                      "TRY1", "TRY2", "EXCEPT", "WS" ]

    RULE_program = 0
    RULE_main_func = 1
    RULE_statements = 2
    RULE_statement = 3
    RULE_print_stmt = 4
    RULE_print_str = 5
    RULE_print_expression = 6
    RULE_condition_stmt = 7
    RULE_while_stmt = 8
    RULE_try_except = 9
    RULE_var_assign = 10
    RULE_expression = 11
    RULE_operations = 12
    RULE_operation = 13

    ruleNames =  [ "program", "main_func", "statements", "statement", "print_stmt", 
                   "print_str", "print_expression", "condition_stmt", "while_stmt", 
                   "try_except", "var_assign", "expression", "operations", 
                   "operation" ]

    EOF = Token.EOF
    TRUE=1
    FALSE=2
    NOTEQ1=3
    NOTEQ2=4
    ASSIGN1=5
    ASSIGN2=6
    WHILE=7
    END=8
    IF=9
    ELIF=10
    ELSE=11
    ENDIF=12
    PRINT=13
    AND1=14
    AND2=15
    AND3=16
    OR1=17
    OR2=18
    NOT=19
    LESS1=20
    LESS2=21
    DECREMENT=22
    INCREMENT=23
    ID=24
    INT=25
    STRING=26
    BEGINMAIN=27
    ENDMAIN=28
    SUBOP1=29
    DIVOP1=30
    ADDOP=31
    MULOP=32
    SUBOP2=33
    DIVOP2=34
    TRY1=35
    TRY2=36
    EXCEPT=37
    WS=38

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def main_func(self):
            return self.getTypedRuleContext(TommyWiCParser.Main_funcContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_program

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = TommyWiCParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self.main_func()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Main_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGINMAIN(self):
            return self.getToken(TommyWiCParser.BEGINMAIN, 0)

        def statements(self):
            return self.getTypedRuleContext(TommyWiCParser.StatementsContext,0)


        def ENDMAIN(self):
            return self.getToken(TommyWiCParser.ENDMAIN, 0)

        def getRuleIndex(self):
            return TommyWiCParser.RULE_main_func

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMain_func" ):
                return visitor.visitMain_func(self)
            else:
                return visitor.visitChildren(self)




    def main_func(self):

        localctx = TommyWiCParser.Main_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_main_func)
        try:
            self.state = 36
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 30
                self.match(TommyWiCParser.BEGINMAIN)
                self.state = 31
                self.statements()
                self.state = 32
                self.match(TommyWiCParser.ENDMAIN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 34
                self.match(TommyWiCParser.BEGINMAIN)
                self.state = 35
                self.match(TommyWiCParser.ENDMAIN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.StatementContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.StatementContext,i)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_statements

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatements" ):
                return visitor.visitStatements(self)
            else:
                return visitor.visitChildren(self)




    def statements(self):

        localctx = TommyWiCParser.StatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 38
                    self.statement() 
                self.state = 43
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_assign(self):
            return self.getTypedRuleContext(TommyWiCParser.Var_assignContext,0)


        def operations(self):
            return self.getTypedRuleContext(TommyWiCParser.OperationsContext,0)


        def print_stmt(self):
            return self.getTypedRuleContext(TommyWiCParser.Print_stmtContext,0)


        def condition_stmt(self):
            return self.getTypedRuleContext(TommyWiCParser.Condition_stmtContext,0)


        def while_stmt(self):
            return self.getTypedRuleContext(TommyWiCParser.While_stmtContext,0)


        def try_except(self):
            return self.getTypedRuleContext(TommyWiCParser.Try_exceptContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_statement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = TommyWiCParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        try:
            self.state = 50
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.var_assign()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.operations(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.print_stmt()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 47
                self.condition_stmt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 48
                self.while_stmt()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 49
                self.try_except()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def print_str(self):
            return self.getTypedRuleContext(TommyWiCParser.Print_strContext,0)


        def print_expression(self):
            return self.getTypedRuleContext(TommyWiCParser.Print_expressionContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_print_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint_stmt" ):
                return visitor.visitPrint_stmt(self)
            else:
                return visitor.visitChildren(self)




    def print_stmt(self):

        localctx = TommyWiCParser.Print_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_print_stmt)
        try:
            self.state = 54
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 52
                self.print_str()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.print_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_strContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINT(self):
            return self.getToken(TommyWiCParser.PRINT, 0)

        def STRING(self):
            return self.getToken(TommyWiCParser.STRING, 0)

        def getRuleIndex(self):
            return TommyWiCParser.RULE_print_str

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint_str" ):
                return visitor.visitPrint_str(self)
            else:
                return visitor.visitChildren(self)




    def print_str(self):

        localctx = TommyWiCParser.Print_strContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_print_str)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.match(TommyWiCParser.PRINT)
            self.state = 57
            self.match(TommyWiCParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Print_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINT(self):
            return self.getToken(TommyWiCParser.PRINT, 0)

        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_print_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint_expression" ):
                return visitor.visitPrint_expression(self)
            else:
                return visitor.visitChildren(self)




    def print_expression(self):

        localctx = TommyWiCParser.Print_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_print_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self.match(TommyWiCParser.PRINT)
            self.state = 60
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Condition_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(TommyWiCParser.IF, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,i)


        def statements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.StatementsContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.StatementsContext,i)


        def ENDIF(self):
            return self.getToken(TommyWiCParser.ENDIF, 0)

        def ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(TommyWiCParser.ELIF)
            else:
                return self.getToken(TommyWiCParser.ELIF, i)

        def ELSE(self):
            return self.getToken(TommyWiCParser.ELSE, 0)

        def getRuleIndex(self):
            return TommyWiCParser.RULE_condition_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition_stmt" ):
                return visitor.visitCondition_stmt(self)
            else:
                return visitor.visitChildren(self)




    def condition_stmt(self):

        localctx = TommyWiCParser.Condition_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_condition_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(TommyWiCParser.IF)
            self.state = 63
            self.expression(0)
            self.state = 64
            self.statements()
            self.state = 71
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==10:
                self.state = 65
                self.match(TommyWiCParser.ELIF)
                self.state = 66
                self.expression(0)
                self.state = 67
                self.statements()
                self.state = 73
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 74
                self.match(TommyWiCParser.ELSE)
                self.state = 75
                self.statements()


            self.state = 78
            self.match(TommyWiCParser.ENDIF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class While_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(TommyWiCParser.WHILE, 0)

        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def statements(self):
            return self.getTypedRuleContext(TommyWiCParser.StatementsContext,0)


        def END(self):
            return self.getToken(TommyWiCParser.END, 0)

        def getRuleIndex(self):
            return TommyWiCParser.RULE_while_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhile_stmt" ):
                return visitor.visitWhile_stmt(self)
            else:
                return visitor.visitChildren(self)




    def while_stmt(self):

        localctx = TommyWiCParser.While_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_while_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(TommyWiCParser.WHILE)
            self.state = 81
            self.expression(0)
            self.state = 82
            self.statements()
            self.state = 83
            self.match(TommyWiCParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Try_exceptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRY1(self):
            return self.getToken(TommyWiCParser.TRY1, 0)

        def operations(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.OperationsContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.OperationsContext,i)


        def TRY2(self):
            return self.getToken(TommyWiCParser.TRY2, 0)

        def EXCEPT(self):
            return self.getToken(TommyWiCParser.EXCEPT, 0)

        def statements(self):
            return self.getTypedRuleContext(TommyWiCParser.StatementsContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_try_except

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTry_except" ):
                return visitor.visitTry_except(self)
            else:
                return visitor.visitChildren(self)




    def try_except(self):

        localctx = TommyWiCParser.Try_exceptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_try_except)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.match(TommyWiCParser.TRY1)
            self.state = 86
            self.operations(0)
            self.state = 87
            self.match(TommyWiCParser.TRY2)
            self.state = 88
            self.match(TommyWiCParser.EXCEPT)
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 89
                self.operations(0)
                pass

            elif la_ == 2:
                self.state = 90
                self.statements()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_assignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)

        def ASSIGN1(self):
            return self.getToken(TommyWiCParser.ASSIGN1, 0)

        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def ASSIGN2(self):
            return self.getToken(TommyWiCParser.ASSIGN2, 0)

        def getRuleIndex(self):
            return TommyWiCParser.RULE_var_assign

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_assign" ):
                return visitor.visitVar_assign(self)
            else:
                return visitor.visitChildren(self)




    def var_assign(self):

        localctx = TommyWiCParser.Var_assignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_var_assign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(TommyWiCParser.ID)
            self.state = 94
            self.match(TommyWiCParser.ASSIGN1)
            self.state = 95
            self.expression(0)
            self.state = 96
            self.match(TommyWiCParser.ASSIGN2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TommyWiCParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class NotContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(TommyWiCParser.NOT, 0)
        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot" ):
                return visitor.visitNot(self)
            else:
                return visitor.visitChildren(self)


    class OrContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OR1(self):
            return self.getToken(TommyWiCParser.OR1, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,i)

        def OR2(self):
            return self.getToken(TommyWiCParser.OR2, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOr" ):
                return visitor.visitOr(self)
            else:
                return visitor.visitChildren(self)


    class AndContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def AND1(self):
            return self.getToken(TommyWiCParser.AND1, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,i)

        def AND2(self):
            return self.getToken(TommyWiCParser.AND2, 0)
        def AND3(self):
            return self.getToken(TommyWiCParser.AND3, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnd" ):
                return visitor.visitAnd(self)
            else:
                return visitor.visitChildren(self)


    class VarexprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarexpr" ):
                return visitor.visitVarexpr(self)
            else:
                return visitor.visitChildren(self)


    class TrueexprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE(self):
            return self.getToken(TommyWiCParser.TRUE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueexpr" ):
                return visitor.visitTrueexpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberexprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(TommyWiCParser.INT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberexpr" ):
                return visitor.visitNumberexpr(self)
            else:
                return visitor.visitChildren(self)


    class FalseexprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE(self):
            return self.getToken(TommyWiCParser.FALSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFalseexpr" ):
                return visitor.visitFalseexpr(self)
            else:
                return visitor.visitChildren(self)


    class LessContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,i)

        def LESS1(self):
            return self.getToken(TommyWiCParser.LESS1, 0)
        def LESS2(self):
            return self.getToken(TommyWiCParser.LESS2, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLess" ):
                return visitor.visitLess(self)
            else:
                return visitor.visitChildren(self)


    class NoteqContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TommyWiCParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,i)

        def NOTEQ1(self):
            return self.getToken(TommyWiCParser.NOTEQ1, 0)
        def NOTEQ2(self):
            return self.getToken(TommyWiCParser.NOTEQ2, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNoteq" ):
                return visitor.visitNoteq(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TommyWiCParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 22
        self.enterRecursionRule(localctx, 22, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [24]:
                localctx = TommyWiCParser.VarexprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 99
                self.match(TommyWiCParser.ID)
                pass
            elif token in [25]:
                localctx = TommyWiCParser.NumberexprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 100
                self.match(TommyWiCParser.INT)
                pass
            elif token in [1]:
                localctx = TommyWiCParser.TrueexprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 101
                self.match(TommyWiCParser.TRUE)
                pass
            elif token in [2]:
                localctx = TommyWiCParser.FalseexprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 102
                self.match(TommyWiCParser.FALSE)
                pass
            elif token in [14]:
                localctx = TommyWiCParser.AndContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 103
                self.match(TommyWiCParser.AND1)
                self.state = 104
                self.expression(0)
                self.state = 105
                self.match(TommyWiCParser.AND2)
                self.state = 106
                self.expression(0)
                self.state = 107
                self.match(TommyWiCParser.AND3)
                pass
            elif token in [17]:
                localctx = TommyWiCParser.OrContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 109
                self.match(TommyWiCParser.OR1)
                self.state = 110
                self.expression(0)
                self.state = 111
                self.match(TommyWiCParser.OR2)
                self.state = 112
                self.expression(3)
                pass
            elif token in [19]:
                localctx = TommyWiCParser.NotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 114
                self.match(TommyWiCParser.NOT)
                self.state = 115
                self.expression(2)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 130
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 128
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        localctx = TommyWiCParser.LessContext(self, TommyWiCParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 118
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 119
                        self.match(TommyWiCParser.LESS1)
                        self.state = 120
                        self.expression(0)
                        self.state = 121
                        self.match(TommyWiCParser.LESS2)
                        pass

                    elif la_ == 2:
                        localctx = TommyWiCParser.NoteqContext(self, TommyWiCParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 123
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 124
                        self.match(TommyWiCParser.NOTEQ1)
                        self.state = 125
                        self.expression(0)
                        self.state = 126
                        self.match(TommyWiCParser.NOTEQ2)
                        pass

             
                self.state = 132
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class OperationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operation(self):
            return self.getTypedRuleContext(TommyWiCParser.OperationContext,0)


        def operations(self):
            return self.getTypedRuleContext(TommyWiCParser.OperationsContext,0)


        def getRuleIndex(self):
            return TommyWiCParser.RULE_operations

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperations" ):
                return visitor.visitOperations(self)
            else:
                return visitor.visitChildren(self)



    def operations(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TommyWiCParser.OperationsContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_operations, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.operation()
            self._ctx.stop = self._input.LT(-1)
            self.state = 140
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TommyWiCParser.OperationsContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_operations)
                    self.state = 136
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 137
                    self.operation() 
                self.state = 142
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return TommyWiCParser.RULE_operation

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DivopContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIVOP1(self):
            return self.getToken(TommyWiCParser.DIVOP1, 0)
        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)
        def DIVOP2(self):
            return self.getToken(TommyWiCParser.DIVOP2, 0)
        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivop" ):
                return visitor.visitDivop(self)
            else:
                return visitor.visitChildren(self)


    class MulopContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)
        def MULOP(self):
            return self.getToken(TommyWiCParser.MULOP, 0)
        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMulop" ):
                return visitor.visitMulop(self)
            else:
                return visitor.visitChildren(self)


    class DecrementContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)
        def DECREMENT(self):
            return self.getToken(TommyWiCParser.DECREMENT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecrement" ):
                return visitor.visitDecrement(self)
            else:
                return visitor.visitChildren(self)


    class MinusopContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUBOP1(self):
            return self.getToken(TommyWiCParser.SUBOP1, 0)
        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)
        def SUBOP2(self):
            return self.getToken(TommyWiCParser.SUBOP2, 0)
        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinusop" ):
                return visitor.visitMinusop(self)
            else:
                return visitor.visitChildren(self)


    class IncrementContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INCREMENT(self):
            return self.getToken(TommyWiCParser.INCREMENT, 0)
        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncrement" ):
                return visitor.visitIncrement(self)
            else:
                return visitor.visitChildren(self)


    class PlusopContext(OperationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a TommyWiCParser.OperationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(TommyWiCParser.ID, 0)
        def ADDOP(self):
            return self.getToken(TommyWiCParser.ADDOP, 0)
        def expression(self):
            return self.getTypedRuleContext(TommyWiCParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlusop" ):
                return visitor.visitPlusop(self)
            else:
                return visitor.visitChildren(self)



    def operation(self):

        localctx = TommyWiCParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_operation)
        try:
            self.state = 161
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = TommyWiCParser.PlusopContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.match(TommyWiCParser.ID)
                self.state = 144
                self.match(TommyWiCParser.ADDOP)
                self.state = 145
                self.expression(0)
                pass

            elif la_ == 2:
                localctx = TommyWiCParser.MinusopContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 146
                self.match(TommyWiCParser.SUBOP1)
                self.state = 147
                self.match(TommyWiCParser.ID)
                self.state = 148
                self.match(TommyWiCParser.SUBOP2)
                self.state = 149
                self.expression(0)
                pass

            elif la_ == 3:
                localctx = TommyWiCParser.MulopContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 150
                self.match(TommyWiCParser.ID)
                self.state = 151
                self.match(TommyWiCParser.MULOP)
                self.state = 152
                self.expression(0)
                pass

            elif la_ == 4:
                localctx = TommyWiCParser.DivopContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 153
                self.match(TommyWiCParser.DIVOP1)
                self.state = 154
                self.match(TommyWiCParser.ID)
                self.state = 155
                self.match(TommyWiCParser.DIVOP2)
                self.state = 156
                self.expression(0)
                pass

            elif la_ == 5:
                localctx = TommyWiCParser.DecrementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 157
                self.match(TommyWiCParser.ID)
                self.state = 158
                self.match(TommyWiCParser.DECREMENT)
                pass

            elif la_ == 6:
                localctx = TommyWiCParser.IncrementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 159
                self.match(TommyWiCParser.INCREMENT)
                self.state = 160
                self.match(TommyWiCParser.ID)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[11] = self.expression_sempred
        self._predicates[12] = self.operations_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def operations_sempred(self, localctx:OperationsContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 1)
         




